package com.example.m2bikson.myrubik2018;

public class CommandsToNXT {
    /**
     * define the messages of commands which are sent to NXT mindstore via BlueTooth
     */
    byte motorBPowerReverse = (byte) 0xCE;//tried 50% (0x32, 0xCE)//40% is tried and is not good.
    byte motorBPowerClockwise = (byte) 0x32;
    byte[] motorCPushMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x02, 0x32, 0x07, 0x01, 0x00, 0x10, 0x63, 0x00, 0x00, 0x00};//0x63 may better//first try 80 degree(0x0050)--> then try 90 degree(0x005A) then try 0x60(96 degree)//RampupSpeedMotorONwithBreakRegulated; 80 degree =0x50, 0x00,
    byte[] motorCReleaseMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x02, 0x32, 0x07, 0x01, 0x00, 0x10, (byte) 0xB4, 0x00, 0x00, 0x00}; //RampupSpeedMotorONwithBreakRegulated; 180 degree = (byte) 0xB4, 0x00
    byte[] motorCPullMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x02, (byte) 0xCE, 0x07, 0x01, 0x00, 0x10, 0x63, 0x00, 0x00, 0x00}; //first try 80 degree(0x0050)--> then try 90 degree(0x005A) then try 0x60(96 degree)//RampupSpeedMotorONwithBreakRegulated; 80 degree =0x50, 0x00,

    byte[] motorCPushMessagePlus = {0x0C, 0x00, (byte) 0x80, 0x04, 0x02, 0x32, 0x07, 0x01, 0x00, 0x10, (byte) 0x84, 0x00, 0x00, 0x00};//0x63 may better//first try 80 degree(0x0050)--> then try 90 degree(0x005A) then try 0x60(96 degree)//RampupSpeedMotorONwithBreakRegulated; 80 degree =0x50, 0x00,
    byte[] motorCPullMessagePlus = {0x0C, 0x00, (byte) 0x80, 0x04, 0x02, (byte) 0xCE, 0x07, 0x01, 0x00, 0x10, (byte) 0x84, 0x00, 0x00, 0x00}; //first try 80 degree(0x0050)--> then try 90 degree(0x005A) then try 0x60(96 degree)//RampupSpeedMotorONwithBreakRegulated; 80 degree =0x50, 0x00,


    byte[] motorBCounterClockwise90Message = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerClockwise, 0x07, 0x01, 0x00, 0x10, 0x47, 0x01, 0x00, 0x00}; //RampupSpeedMotorONwithBreakRegulated//this over rolling, so minus 1 degree. but dont change *adjust and peer-reverse rolling
    byte[] motorBClockwise90Message = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerReverse, 0x07, 0x01, 0x00, 0x10, 0x47, 0x01, 0x00, 0x00};//TestRRampDownSpeedMotorONwithBreakRegulated

    byte[] motorBClockwise90adjustMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerReverse, 0x07, 0x01, 0x00, 0x10, 0x38, 0x00, 0x00, 0x00};//TestRRampDownSpeedMotorONwithBreakRegulated
    byte[] motorBCounterClockwise90adjustMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerClockwise, 0x07, 0x01, 0x00, 0x10, 0x38, 0x00, 0x00, 0x00};//change 0x33 degree to 0x38 degrees

    byte[] errorMotorBClockwise90adjustMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerReverse, 0x07, 0x01, 0x00, 0x10, 0x50, 0x00, 0x00, 0x00};//0x50 =0x38 + 0x18; change 0x33 degree to 0x38 degrees. rolling rubik 1 degree need rolling wheel 3.633 degree. need modify about 6.5*2=13 degree in rubik.

    byte[] motorBCounterClockwise180Message = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerClockwise, 0x07, 0x01, 0x00, 0x10, (byte) 0x82, 0x02, 0x00, 0x00}; //first try 591 degree(0x24F)--> then try 642 degree(0x282)  //TestRRampDownSpeedMotorONwithBreakRegulated
    byte[] motorBClockwise180Message = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerReverse, 0x07, 0x01, 0x00, 0x10, (byte) 0x82, 0x02, 0x00, 0x00};//first try 591 degree(0x24F)--> then try 642 degree(0x282) //RampupSpeedMotorONwithBreakRegulated

    //let the rubik turn more to correct error of motor B.
    byte[] motorBClockwiseCorrectionMessage = {0x0C, 0x00, (byte) 0x80, 0x04, 0x01, motorBPowerReverse, 0x07, 0x01, 0x00, 0x10, 0x0C, 0x00, 0x00, 0x00};//TestRRampDownSpeedMotorONwithBreakRegulated
    // play tone
    byte[] PlayToneData = {0x06, 0x00, 0x00, 0x03, 0x0B, 0x02, (byte) 0xF4, 0x01};// reply 0x03 0x00 0x02 0x03 0x00
    // set motor
    byte[] SetOutputStateData = {0x0C, 0x00, 0x00, 0x04, 0x01, 0x32, 0x05, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00};
    // get output state of motor
    byte[] GetOutputStateData = {0x03, 0x00, (byte) 0x00, 0x06, 0x02};
    // reset motor position
    byte[] ResetMotorPositionData = {0x04, 0x00, (byte) 0x00, 0x0A, 0x02, 0x00};//0x0A-->10  port C: 0x02

    byte[] GetOutputStateFeed = new byte[27];//should be 27? adding two for length of package
    byte[] GetInputValuesFeed = new byte[16];

}
